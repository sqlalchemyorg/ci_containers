commit 1ec90f4997bc3125499cb781492413068f7cb194
Author: Mike Bayer <mike_mp@zzzcomputing.com>
Date:   Mon Aug 24 12:00:04 2020 -0400

    Accommodate immutable URL api
    
    SQLAlchemy 1.4 is likely going to switch the URL
    object to a new immutable URL.  This patch makes the
    adjustments needed, using duck-typing to check if the
    URL object is of the new style.
    
    WIP as I am still cross-testing the patch on the
    SQLAlchemy side.
    
    Change-Id: Id2f0663b13ed0f81e91a8d44f73d8541015bf844

diff --git a/oslo_db/sqlalchemy/engines.py b/oslo_db/sqlalchemy/engines.py
index 25215b9..3387b10 100644
--- a/oslo_db/sqlalchemy/engines.py
+++ b/oslo_db/sqlalchemy/engines.py
@@ -105,6 +105,10 @@ def _setup_logging(connection_debug=0):
 
 
 def _extend_url_parameters(url, connection_parameters):
+    # 1.4
+    if hasattr(url, "update_query_string"):
+        return url.update_query_string(connection_parameters, append=True)
+
     for key, value in parse.parse_qs(
             connection_parameters).items():
         if key in url.query:
@@ -118,6 +122,8 @@ def _extend_url_parameters(url, connection_parameters):
         if len(value) == 1:
             url.query[key] = value[0]
 
+    return url
+
 
 def _vet_url(url):
     if "+" not in url.drivername and not url.drivername.startswith("sqlite"):
@@ -127,13 +133,13 @@ def _vet_url(url):
                 "and will make use of a default driver.  "
                 "A full dbname+drivername:// protocol is recommended. "
                 "For MySQL, it is strongly recommended that mysql+pymysql:// "
-                "be specified for maximum service compatibility", url
+                "be specified for maximum service compatibility", (url, )
             )
         else:
             LOG.warning(
                 "URL %r does not contain a '+drivername' portion, "
                 "and will make use of a default driver.  "
-                "A full dbname+drivername:// protocol is recommended.", url
+                "A full dbname+drivername:// protocol is recommended.", (url, )
             )
 
 
@@ -153,7 +159,7 @@ def create_engine(sql_connection, sqlite_fk=False, mysql_sql_mode=None,
     url = sqlalchemy.engine.url.make_url(sql_connection)
 
     if connection_parameters:
-        _extend_url_parameters(url, connection_parameters)
+        url = _extend_url_parameters(url, connection_parameters)
 
     _vet_url(url)
 
diff --git a/oslo_db/sqlalchemy/provision.py b/oslo_db/sqlalchemy/provision.py
index 2fc3a54..d51634f 100644
--- a/oslo_db/sqlalchemy/provision.py
+++ b/oslo_db/sqlalchemy/provision.py
@@ -495,8 +495,11 @@ class BackendImpl(object, metaclass=abc.ABCMeta):
         """
 
         url = sa_url.make_url(str(base_url))
-        url.database = ident
-        return url
+        if hasattr(url, "set"):
+            return url.set(database=ident)
+        else:
+            url.database = ident
+            return url
 
 
 @BackendImpl.impl.dispatch_for("mysql")
diff --git a/oslo_db/tests/sqlalchemy/test_exc_filters.py b/oslo_db/tests/sqlalchemy/test_exc_filters.py
index 0451c89..35803ff 100644
--- a/oslo_db/tests/sqlalchemy/test_exc_filters.py
+++ b/oslo_db/tests/sqlalchemy/test_exc_filters.py
@@ -386,8 +386,11 @@ class TestNonExistentDatabase(
         super(TestNonExistentDatabase, self).setUp()
 
         url = sqla_url.make_url(str(self.engine.url))
-        url.database = 'non_existent_database'
-        self.url = url
+        if hasattr(url, "set"):
+            self.url = url.set(database="non_existent_database")
+        else:
+            url.database = 'non_existent_database'
+            self.url = url
 
     def test_raise(self):
         matched = self.assertRaises(
diff --git a/oslo_db/tests/sqlalchemy/test_sqlalchemy.py b/oslo_db/tests/sqlalchemy/test_sqlalchemy.py
index 080f418..eb89a92 100644
--- a/oslo_db/tests/sqlalchemy/test_sqlalchemy.py
+++ b/oslo_db/tests/sqlalchemy/test_sqlalchemy.py
@@ -229,6 +229,16 @@ class QueryParamTest(test_base.DbTestCase):
             "oslo_db.sqlalchemy.engines.sqlalchemy.create_engine",
             side_effect=_mock_create_engine)
 
+    def _normalize_query_dict(self, qdict):
+        # SQLAlchemy 1.4 returns url.query as:
+        # immutabledict({k1: v1, k2: (v2a, v2b, ...), ...})
+        # that is with tuples not lists for multiparams
+
+        return {
+            k: list(v) if isinstance(v, tuple) else v
+            for k, v in qdict.items()
+        }
+
     def test_add_assorted_params(self):
         with self._fixture() as ce:
             engines.create_engine(
@@ -236,7 +246,7 @@ class QueryParamTest(test_base.DbTestCase):
                 connection_parameters="foo=bar&bat=hoho&bat=param2")
 
         self.assertEqual(
-            ce.mock_calls[0][1][0].query,
+            self._normalize_query_dict(ce.mock_calls[0][1][0].query),
             {'bat': ['hoho', 'param2'], 'foo': 'bar'}
         )
 
@@ -247,7 +257,7 @@ class QueryParamTest(test_base.DbTestCase):
 
         self.assertEqual(
             ce.mock_calls[0][1][0].query,
-            {}
+            self._normalize_query_dict({})
         )
 
     def test_combine_params(self):
@@ -260,7 +270,7 @@ class QueryParamTest(test_base.DbTestCase):
                                       "bind_host=192.168.1.5")
 
         self.assertEqual(
-            ce.mock_calls[0][1][0].query,
+            self._normalize_query_dict(ce.mock_calls[0][1][0].query),
             {
                 'bind_host': '192.168.1.5',
                 'charset': 'utf8',
@@ -280,7 +290,7 @@ class QueryParamTest(test_base.DbTestCase):
                                       "bind_host=192.168.1.5")
 
         self.assertEqual(
-            ce.mock_calls[0][1][0].query,
+            self._normalize_query_dict(ce.mock_calls[0][1][0].query),
             {
                 'bind_host': '192.168.1.5',
                 'charset': 'utf8',
